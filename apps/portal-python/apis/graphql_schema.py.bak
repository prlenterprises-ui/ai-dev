"""
GraphQL Schema using Strawberry.

This is the unified GraphQL schema that combines all modules:
- Resume generation (jobbernaut-tailor)
- LLM Council deliberation
- Resume matching and scoring
- Job application tracking
- Configuration management

Strawberry uses Python type hints for schema definition,
making it very Pythonic and easy to maintain.
"""

from datetime import datetime
from typing import Optional
import json

import strawberry
from sqlmodel import select
from python.database import Config as ConfigModel, get_session

# =============================================================================
# TYPES - Data structures returned by the API
# =============================================================================


@strawberry.type
class Module:
    """Represents one of the integrated submodules."""

    id: str
    name: str
    description: str
    status: str  # "active", "coming_soon", "maintenance"
    icon: str
    route: str


@strawberry.type
class HealthStatus:
    """API health check response."""

    status: str
    timestamp: datetime
    version: str
    modules_loaded: int


@strawberry.type
class LLMResponse:
    """Response from an LLM query."""

    model: str
    content: str
    tokens_used: int
    latency_ms: int


@strawberry.type
class CouncilDeliberation:
    """Result of LLM Council deliberation."""

    query: str
    individual_responses: list[LLMResponse]
    rankings: list[str]
    final_answer: str
    chairman_model: str


@strawberry.type
class ResumeScore:
    """Resume matching score against a job description."""

    overall_score: float
    keyword_match: float
    ats_compatibility: float
    suggestions: list[str]


@strawberry.type
class JobApplication:
    """A job application record."""

    id: str
    job_title: str
    company: str
    status: str  # "pending", "processing", "completed", "failed"
    created_at: datetime
    resume_url: Optional[str] = None
    cover_letter_url: Optional[str] = None


@strawberry.type
class ConfigType:
    """Application configuration."""

    id: int
    name: str
    title: str
    description: Optional[str]
    config: strawberry.scalars.JSON
    created_at: datetime
    updated_at: datetime


# =============================================================================
# INPUTS - Data structures for mutations
# =============================================================================


@strawberry.input
class CouncilQueryInput:
    """Input for LLM Council query."""

    query: str
    models: Optional[list[str]] = None  # If None, use defaults
    chairman_model: Optional[str] = None


@strawberry.input
class ResumeMatchInput:
    """Input for resume matching."""

    resume_text: str
    job_description: str


@strawberry.input
class JobApplicationInput:
    """Input for creating a job application."""

    job_title: str
    company: str
    job_description: str
    job_url: Optional[str] = None


@strawberry.input
class ConfigInput:
    """Input for creating a configuration."""

    name: str
    title: str
    description: Optional[str] = None
    config: strawberry.scalars.JSON


@strawberry.input
class ConfigUpdateInput:
    """Input for updating a configuration."""

    title: Optional[str] = None
    description: Optional[str] = None
    config: Optional[strawberry.scalars.JSON] = None


# =============================================================================
# QUERIES - Read operations
# =============================================================================


@strawberry.type
class Query:
    """Root Query type - all read operations."""

    @strawberry.field
    def health(self) -> HealthStatus:
        """Check API health status."""
        return HealthStatus(
            status="healthy",
            timestamp=datetime.now(),
            version="0.1.0",
            modules_loaded=5,
        )

    @strawberry.field
    def modules(self) -> list[Module]:
        """Get list of all available modules."""
        return [
            Module(
                id="jobbernaut",
                name="Jobbernaut Tailor",
                description="Industrial-scale resume tailoring with AI validation",
                status="active",
                icon="ðŸ“„",
                route="/jobbernaut",
            ),
            Module(
                id="llm-council",
                name="LLM Council",
                description="Multi-LLM deliberation with peer review",
                status="active",
                icon="ðŸ›ï¸",
                route="/council",
            ),
            Module(
                id="resume-matcher",
                name="Resume Matcher",
                description="Local AI resume analysis with Ollama",
                status="active",
                icon="ðŸŽ¯",
                route="/matcher",
            ),
            Module(
                id="resume-lm",
                name="ResumeLM",
                description="Full-featured AI resume builder",
                status="coming_soon",
                icon="âœ¨",
                route="/resume-lm",
            ),
            Module(
                id="aihawk",
                name="AIHawk",
                description="Automated job application agent",
                status="coming_soon",
                icon="ðŸ¦…",
                route="/aihawk",
            ),
        ]

    @strawberry.field
    def module(self, id: str) -> Optional[Module]:
        """Get a specific module by ID."""
        modules = self.modules()
        return next((m for m in modules if m.id == id), None)

    @strawberry.field
    def applications(self, status: Optional[str] = None) -> list[JobApplication]:
        """Get job applications, optionally filtered by status."""
        # TODO: Implement database query
        # For now, return mock data
        mock_apps = [
            JobApplication(
                id="app-001",
                job_title="Senior Software Engineer",
                company="TechCorp",
                status="completed",
                created_at=datetime.now(),
                resume_url="/outputs/resume.pdf",
                cover_letter_url="/outputs/cover_letter.pdf",
            ),
            JobApplication(
                id="app-002",
                job_title="Staff Engineer",
                company="StartupXYZ",
                status="pending",
                created_at=datetime.now(),
            ),
        ]
        if status:
            return [a for a in mock_apps if a.status == status]
        return mock_apps

    @strawberry.field
    async def configs(self, info: strawberry.Info) -> list[ConfigType]:
        """Get all configurations."""
        async for session in get_session():
            result = await session.execute(select(ConfigModel))
            configs = result.scalars().all()
            return [
                ConfigType(
                    id=config.id,
                    name=config.name,
                    title=config.title,
                    description=config.description,
                    config=json.loads(config.config_json),
                    created_at=config.created_at,
                    updated_at=config.updated_at,
                )
                for config in configs
            ]
        return []

    @strawberry.field
    async def config(self, info: strawberry.Info, name: str) -> Optional[ConfigType]:
        """Get a specific configuration by name."""
        async for session in get_session():
            result = await session.execute(select(ConfigModel).where(ConfigModel.name == name))
            config = result.scalar_one_or_none()
            if config:
                return ConfigType(
                    id=config.id,
                    name=config.name,
                    title=config.title,
                    description=config.description,
                    config=json.loads(config.config_json),
                    created_at=config.created_at,
                    updated_at=config.updated_at,
                )
        return None


# =============================================================================
# MUTATIONS - Write operations
# =============================================================================


@strawberry.type
class Mutation:
    """Root Mutation type - all write operations."""

    @strawberry.mutation
    async def ask_council(self, input: CouncilQueryInput) -> CouncilDeliberation:
        """
        Query the LLM Council for a deliberated answer.

        This triggers:
        1. Parallel queries to all council models
        2. Anonymous peer review and ranking
        3. Chairman synthesis of final answer
        """
        import os

        from ..ai.council import LLMCouncil

        # Get API key from environment
        api_key = os.getenv("OPENROUTER_API_KEY")
        if not api_key:
            # Return error as a deliberation result
            error_msg = (
                "Error: OPENROUTER_API_KEY not configured. "
                "Please set the API key to use the LLM Council."
            )
            return CouncilDeliberation(
                query=input.query,
                individual_responses=[],
                rankings=[],
                final_answer=error_msg,
                chairman_model="none",
            )

        # Run council deliberation
        council = LLMCouncil(api_key=api_key)
        try:
            result = await council.deliberate(input.query)

            # Convert to GraphQL types
            responses = [
                LLMResponse(
                    model=model,
                    content=resp.content,
                    tokens_used=resp.tokens_used,
                    latency_ms=resp.latency_ms,
                )
                for model, resp in result.stage1_responses.items()
            ]

            rankings = [model for model, _ in result.aggregate_rankings]

            return CouncilDeliberation(
                query=result.query,
                individual_responses=responses,
                rankings=rankings,
                final_answer=result.final_answer,
                chairman_model=result.chairman_model,
            )
        except Exception as e:
            # Return error in deliberation format
            return CouncilDeliberation(
                query=input.query,
                individual_responses=[],
                rankings=[],
                final_answer=f"Error during deliberation: {str(e)}",
                chairman_model="error",
            )

    @strawberry.mutation
    async def match_resume(self, input: ResumeMatchInput) -> ResumeScore:
        """
        Analyze how well a resume matches a job description.

        Uses basic keyword matching and ATS compatibility checks.
        """
        # Basic keyword extraction and matching
        resume_lower = input.resume_text.lower()
        job_lower = input.job_description.lower()

        # Extract keywords from job description (simple approach)
        import re

        job_keywords = set(re.findall(r"\b[a-z]{3,}\b", job_lower))
        resume_keywords = set(re.findall(r"\b[a-z]{3,}\b", resume_lower))

        # Common technical keywords to prioritize
        tech_keywords = {
            "python",
            "java",
            "javascript",
            "typescript",
            "golang",
            "react",
            "vue",
            "kubernetes",
            "docker",
            "aws",
            "azure",
            "gcp",
            "sql",
            "nosql",
            "distributed",
            "microservices",
            "api",
            "rest",
            "graphql",
            "kafka",
            "redis",
            "postgresql",
            "mongodb",
            "elasticsearch",
        }

        # Calculate keyword match
        tech_in_job = job_keywords & tech_keywords
        tech_in_resume = resume_keywords & tech_keywords
        tech_match = len(tech_in_job & tech_in_resume)
        tech_total = len(tech_in_job) if tech_in_job else 1

        keyword_score = (tech_match / tech_total) * 100

        # ATS compatibility checks
        ats_score = 70.0
        suggestions = []

        if input.resume_text.count("\n") < 20:
            ats_score -= 10
            suggestions.append("Add more content - resume seems too short")

        if len(re.findall(r"\d+%|\d+x|\$\d+", input.resume_text)) < 3:
            ats_score -= 5
            suggestions.append("Add more quantifiable achievements with numbers")

        # Check for missing tech keywords
        missing_tech = tech_in_job - tech_in_resume
        if missing_tech:
            suggestions.append(f"Consider adding keywords: {', '.join(list(missing_tech)[:5])}")

        # Overall score (weighted average)
        overall_score = (keyword_score * 0.6) + (ats_score * 0.4)

        if not suggestions:
            suggestions.append("Resume looks well-matched to the job description")

        return ResumeScore(
            overall_score=round(overall_score, 1),
            keyword_match=round(keyword_score, 1),
            ats_compatibility=ats_score,
            suggestions=suggestions,
        )

    @strawberry.mutation
    async def create_application(self, input: JobApplicationInput) -> JobApplication:
        """
        Create a new job application and start the tailoring pipeline.

        This triggers the Jobbernaut pipeline:
        1. Job resonance analysis
        2. Company research
        3. Storytelling arc generation
        4. Resume and cover letter generation
        5. PDF compilation
        """
        # Create application record
        # In production, this would save to database
        # JobApplication(
        #     id=app_id,
        #     job_title=input.job_title,
        #     company=input.company,
        #     status="pending",
        #     created_at=datetime.now(),
        # )
        pass

    @strawberry.mutation
    async def create_config(self, info: strawberry.Info, input: ConfigInput) -> ConfigType:
        """Create a new configuration."""
        async for session in get_session():
            # Check if config already exists
            result = await session.execute(select(ConfigModel).where(ConfigModel.name == input.name))
            existing = result.scalar_one_or_none()
            if existing:
                raise Exception(f"Config '{input.name}' already exists")

            config = ConfigModel(
                name=input.name,
                title=input.title,
                description=input.description,
                config_json=json.dumps(input.config),
            )
            session.add(config)
            await session.commit()
            await session.refresh(config)

            return ConfigType(
                id=config.id,
                name=config.name,
                title=config.title,
                description=config.description,
                config=json.loads(config.config_json),
                created_at=config.created_at,
                updated_at=config.updated_at,
            )

    @strawberry.mutation
    async def update_config(
        self, info: strawberry.Info, name: str, input: ConfigUpdateInput
    ) -> ConfigType:
        """Update an existing configuration."""
        async for session in get_session():
            result = await session.execute(select(ConfigModel).where(ConfigModel.name == name))
            config = result.scalar_one_or_none()

            if not config:
                raise Exception(f"Config '{name}' not found")

            if input.title is not None:
                config.title = input.title
            if input.description is not None:
                config.description = input.description
            if input.config is not None:
                config.config_json = json.dumps(input.config)

            config.updated_at = datetime.now()

            await session.commit()
            await session.refresh(config)

            return ConfigType(
                id=config.id,
                name=config.name,
                title=config.title,
                description=config.description,
                config=json.loads(config.config_json),
                created_at=config.created_at,
                updated_at=config.updated_at,
            )

    @strawberry.mutation
    async def delete_config(self, info: strawberry.Info, name: str) -> bool:
        """Delete a configuration."""
        async for session in get_session():
            result = await session.execute(select(ConfigModel).where(ConfigModel.name == name))
            config = result.scalar_one_or_none()

            if not config:
                raise Exception(f"Config '{name}' not found")

            await session.delete(config)
            await session.commit()
            return True


# =============================================================================
# SCHEMA - Combine Query and Mutation
# =============================================================================

schema = strawberry.Schema(query=Query, mutation=Mutation)
